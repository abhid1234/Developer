# ‚úàÔ∏è I Built a Production-Grade "Mission Control" Flight Tracker in 24 Hours

*A deep dive into building, scaling, and polishing a Next.js app on Google Cloud Run.*

---

## üìñ The Context
I‚Äôve always been a data geek. When I travel, I‚Äôm the person refreshing three different apps to see if my inbound plane has left its origin. But the current state of flight tracking apps is... frustrating. They are either:
1.  **Expensive pro tools** (too complex for a quick check).
2.  **Ad-filled free apps** (clunky, slow, and ugly).

I wanted something different. I wanted a **"Mission Control"** experience. A dashboard that looked like it belonged in a modern sci-fi movie‚Äîdark mode, glassmorphism, real-time data, and stunning visuals of the actual aircraft involved.

So, I challenged myself: **Can I build a better flight tracker in one weekend?**

The result is a production-grade application running on Google Cloud Run that handles real-time global flight data with sub-second latency. Here is the full story of how I built it.

---

## üéØ The Vision & Architecture
I didn't want a "Hello World" app. I wanted a robust architecture that could scale.

### The System Design
The app follows a modern **Serverless Edge Architecture**.
*   **The Brain (Next.js)**: Runs as a stateless container. It acts as the API Gateway, fetching data, caching it, and rendering the UI.
*   **The Muscle (Cloud Run)**: Handles the heavy lifting of traffic scaling. If 100 people visit, it scales up. If 0 visit, it scales to zero and costs me money (literally $0).
*   **The Data (AviationStack)**: The source of truth for global flight schedules.

> ![Screenshot: Paste your 'System Diagram' from /architecture page here]
> *Figure 1: High-lvl System Architecture showing the flow from Client -> Cloud Run -> API*

### why Next.js 14 App Router?
I chose the App Router for its **React Server Components (RSC)**.
Flight data doesn't change every millisecond. By fetching data on the server, I can:
1.  **Hide my API Keys**: The client never sees the `AVIATIONSTACK_API_KEY`.
2.  **Reduce Client Bundle**: The heavy data parsing logic stays on the server. The client just receives HTML.

---

## üõ†Ô∏è Feature Deep Dive

### 1. The Dynamic "Flight Card"
Most trackers just show you text: "United 871, B789".
I wanted you to *see* the plane.

I built a **Dynamic Asset Engine** that analyzes the aircraft model string.
*   It detects "B789" or "Dreamliner" -> Maps to a stunning photo of a Boeing 787.
*   It detects "A380" -> Maps to an Airbus A380.
*   It detects "A320" -> Maps to an A320.

It handles the edge cases gracefully. If the API returns `null` (which happens often for scheduled flights), the app seamlessly falls back to a high-quality "Generic Cloud" background so the UI never looks broken.

> ![Screenshot: Paste a screenshot of a Flight Card (e.g., UA100 or LH462) here]
> *Figure 2: The Flight Card adapts its visual identity based on the aircraft model.*

### 2. The "Wall Clock" Time Engine üïí
This was the hardest engineering challenge of the weekend.
Aviation time is unique.
*   If a flight leaves Tokyo at 10:00 AM, passengers call it "10:00 AM".
*   But APIs return it as `2024-12-30T01:00:00Z` (UTC).

If I simply converted that UTC string to my browser's local time (PST), it would say "5:00 PM (Yesterday)". That's technically correct but user-hostile.

**The Solution**: I wrote a custom `Time Normalizer`. I ignore the timezone offset provided by the API and treat the date string as "Face Value" local time.
```typescript
// The logic that saved my sanity
const getLocalTimeParts = (timeStr: string) => {
    // Strip the confusing +00:00 offset provided by the API
    // and treat the time as if it's "Wall Clock" time at the airport.
    const cleanStr = timeStr.replace(/[Zz]|[+-]\d{2}:?\d{2}$/, '');
    return new Date(cleanStr);
};
```
Now, 10:00 AM in Tokyo shows as 10:00 AM for everyone, everywhere.

### 3. The Airport Dashboard
I wanted to answer the question: *"What's happening at JFK right now?"*
I built a dedicated route: `/airport-dashboard`.
*   **Live Search**: Enter any IATA code (LHR, SFO, DXB).
*   **Intelligent Context**: The API gives us airport codes (e.g., "DXB"). Normals don't know what that is. I added a mapping layer to display **"Dubai International"** alongside the code.
*   **Toggle**: Instantly switch between Arrivals and Departures.

> ![Screenshot: Paste a screenshot of the /airport-dashboard page here]
> *Figure 3: The Live Airport Dashboard showing real-time departures with City context.*

---

## üöÄ The Deployment Journey
I use **Google Cloud Run** for everything I build, and this was no exception.

**The Workflow**:
1.  **Dockerize**: I created a multi-stage `Dockerfile` to produce a tiny (100MB) standalone image.
2.  **Deploy**:
    ```bash
    gcloud run deploy flight-tracker --source . --allow-unauthenticated
    ```
That‚Äôs it. No Kubernetes manifests. No Nginx config. Just code -> running URL.

**The Result**:
*   **Cold Start**: ~2 seconds (optimization for another day!).
*   **Request Latency**: ~300ms.
*   **Cost**: $0.00 (Free Tier).

---

## üèÅ Conclusion & Future Roadmap
What started as a frustration with existing tools turned into a sleek, functional product in under 24 hours.
We improved the UX (photos), solved complex data problems (timezones), and deployed to enterprise-grade infrastructure.

**What's Next?**
*   **"My Hangar"**: A feature to pin/save flights to a watchlist (using LocalStorage).
*   **SMS Alerts**: Hooking up Twilio to text me when my plane lands.

**Try it yourself**: [https://flight-tracker-16016022795.us-central1.run.app](https://flight-tracker-16016022795.us-central1.run.app)

*Built with Next.js, Tailwind, and aviation passion.*

<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Building "Mission Control" - Flight Tracker Block Post</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            line-height: 1.8;
            color: #d1d5db;
            background-color: #111827;
            max-width: 800px;
            margin: 0 auto;
            padding: 40px 20px;
        }

        h1,
        h2,
        h3 {
            color: #f3f4f6;
            margin-top: 2.5rem;
        }

        h1 {
            margin-bottom: 0.5rem;
            font-size: 2.5rem;
            background: linear-gradient(to right, #60a5fa, #a78bfa);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        h2 {
            border-bottom: 1px solid #374151;
            padding-bottom: 10px;
        }

        a {
            color: #60a5fa;
            text-decoration: none;
        }

        a:hover {
            text-decoration: underline;
        }

        img {
            max-width: 100%;
            border-radius: 12px;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.5);
            margin: 30px 0;
            border: 1px solid #374151;
        }

        pre {
            background: #1f2937;
            padding: 20px;
            border-radius: 8px;
            overflow-x: auto;
            font-size: 0.9rem;
            border: 1px solid #374151;
            color: #4ade80;
        }

        blockquote {
            border-left: 4px solid #60a5fa;
            margin: 0;
            padding-left: 20px;
            font-style: italic;
            color: #9ca3af;
        }

        .caption {
            font-size: 0.9rem;
            color: #9ca3af;
            text-align: center;
            margin-top: -20px;
            margin-bottom: 40px;
            font-style: italic;
        }

        code {
            background: #374151;
            padding: 2px 6px;
            border-radius: 4px;
            font-family: monospace;
            color: #4ade80;
        }

        .meta {
            color: #9ca3af;
            font-size: 1.1rem;
            margin-bottom: 3rem;
            border-bottom: 1px solid #374151;
            padding-bottom: 2rem;
        }

        hr {
            border: 0;
            border-top: 1px solid #374151;
            margin: 40px 0;
        }
    </style>
</head>

<body>
    <h1>‚úàÔ∏è Building "Mission Control": How I Engineered a Production-Grade Flight Tracker in 24 Hours</h1>
    <div class="meta">A deep dive into Next.js 14, Serverless Architecture, and the art of polishing a weekend project.
    </div>

    <h2>üìñ The Context: Why Build Another Tracker?</h2>
    <p>I‚Äôve always been a data geek. When I travel, I‚Äôm the person refreshing three different apps to see if my inbound
        plane has left its origin. But the current state of flight tracking apps is... frustrating. They typically fall
        into two buckets:</p>
    <ol>
        <li><strong>Expensive Pro Tools</strong>: Enterprise-grade dashboards (ExpertFlyer, FlightRadar24 Gold) that are
            too complex for a quick check.</li>
        <li><strong>Ad-Filled Free Apps</strong>: Clunky, slow, generic interfaces burying the data I actually care
            about.</li>
    </ol>
    <p>I wanted something different. I wanted a <strong>"Mission Control"</strong> experience. A dashboard that looked
        like it belonged in a modern sci-fi movie‚Äîdark mode, glassmorphism, real-time data, and stunning visuals of the
        actual aircraft involved.</p>
    <p>So, I set a challenge: <strong>Can I build a better, faster, and more beautiful flight tracker in a single
            weekend?</strong></p>
    <p>The result is a production-grade application running on Google Cloud Run that handles real-time global flight
        data with sub-second latency. Here is the engineering story behind it.</p>
    <hr>

    <h2>üéØ The Vision & Architecture</h2>
    <p>I didn't want a "Hello World" app. I wanted a robust architecture that could scale to thousands of users without
        costing a fortune.</p>

    <h3>The System Design</h3>
    <p>The app follows a modern <strong>Serverless Edge Architecture</strong>.</p>

    <img src="public/blog_images/architecture.png" alt="System Architecture">
    <div class="caption">Figure 1: High-Level System Architecture showing the unidirectional data flow.</div>

    <ul>
        <li><strong>The Brain (Next.js 14)</strong>: Runs as a stateless container. It acts as the API Gateway, fetching
            data, caching it, and rendering the UI.</li>
        <li><strong>The Muscle (Cloud Run)</strong>: Handles the heavy lifting of traffic scaling. If 100 people visit,
            it scales up. If 0 visit, it scales to zero.</li>
        <li><strong>The Data (AviationStack)</strong>: The source of truth for global flight schedules.</li>
    </ul>

    <h3>Why Next.js 14 App Router?</h3>
    <p>I chose the App Router specifically for <strong>React Server Components (RSC)</strong>. Flight data doesn't
        change every millisecond. By fetching data on the server, I solved two critical problems:</p>
    <ol>
        <li><strong>Security</strong>: The <code>AVIATIONSTACK_API_KEY</code> never leaves the server environment. The
            client receives clean, hydrated HTML.</li>
        <li><strong>Performance</strong>: The heavy data parsing/sorting logic (which I'll discuss below) happens on the
            high-powered server, not the user's phone.</li>
    </ol>
    <hr>

    <h2>üõ†Ô∏è Engineering Deep Dive</h2>

    <h3>1. The "Smart Sort" Algorithm üß†</h3>
    <p>One of the biggest frustrations with flight APIs is the data dump. You ask for "UA 100" and you get 50 flights:
        some from last year, some from next month, and one active one.</p>
    <p>I implemented a custom <strong>relevancy algorithm</strong> in the API route to serve the "right" flight
        instantly:</p>

    <pre><code>// The "Smart Sort" Logic
// 1. Prioritize ACTIVE flights (in the air right now)
// 2. If none, show the SOONEST UPCOMING flight
// 3. If none, show the MOST RECENT past flight

currentFlight = processedFlights.find(f =>
    f.status === 'Active' && new Date(f.origin.time) > twoDaysAgo
) || processedFlights.find(f => 
    new Date(f.origin.time) > now
) || processedFlights[processedFlights.length - 1];</code></pre>
    <p>This ensures that when you search for a flight, the primary card always shows what is happening <em>now</em>,
        while the history tables cleanly organize the rest.</p>

    <h3>2. The Dynamic "Flight Card" Engine üé®</h3>
    <p>Most trackers just show you text: "United 871, B789". I wanted you to <em>see</em> the plane.</p>
    <p>I built a <strong>Dynamic Asset Engine</strong> that analyzes the aircraft model string.</p>
    <ul>
        <li>It detects "B789" or "Dreamliner" -> Maps to a stunning photo of a Boeing 787.</li>
        <li>It detects "A380" -> Maps to an Airbus A380.</li>
        <li>It detects "A320" -> Maps to an A320.</li>
    </ul>
    <p>It handles the edge cases gracefully. If the API returns <code>null</code> (which happens often for scheduled
        flights), the app seamlessly falls back to a high-quality "Generic Cloud" background so the UI never looks
        broken.</p>

    <img src="public/blog_images/flight_card.png" alt="Flight Card">
    <div class="caption">Figure 2: The Flight Card adapts its visual identity based on the aircraft model.</div>

    <h3>3. The "Wall Clock" Time Challenge üïí</h3>
    <p>This was the hardest engineering challenge of the weekend. Aviation time is unique.</p>
    <ul>
        <li>If a flight leaves Tokyo at 10:00 AM, passengers call it "10:00 AM".</li>
        <li>But APIs return it as <code>2024-12-30T01:00:00Z</code> (UTC).</li>
    </ul>
    <p>If I simply converted that UTC string to my browser's local time (PST), it would say "5:00 PM (Yesterday)".
        That's technically correct but user-hostile.</p>

    <p><strong>The Solution</strong>: I wrote a custom <code>Time Normalizer</code>. I ignore the timezone offset
        provided by the API and treat the date string as "Face Value" local time.</p>
    <pre><code>const getLocalTimeParts = (timeStr: string) => {
    // Strip the confusing +00:00 offset provided by the API
    // and treat the time as if it's "Wall Clock" time at the airport.
    const cleanStr = timeStr.replace(/[Zz]|[+-]\d{2}:?\d{2}$/, '');
    return new Date(cleanStr);
};</code></pre>
    <p>Now, 10:00 AM in Tokyo shows as 10:00 AM for everyone, everywhere.

    <h3>4. The Live Airport Dashboard üõ´</h3>
    <p>I wanted to answer the question: <em>"What's happening at JFK right now?"</em> I built a dedicated route:
        <code>/airport-dashboard</code>.
    </p>
    <ul>
        <li><strong>Live Search</strong>: Enter any IATA code (LHR, SFO, DXB).</li>
        <li><strong>Intelligent Context</strong>: The API gives us airport codes (e.g., "DXB"). Normals don't know what
            that is. I added a mapping layer to display <strong>"Dubai International"** alongside the code.</li>
        <li><strong>Toggle</strong>: Instantly switch between Arrivals and Departures.</li>
    </ul>

    <img src="public/blog_images/dashboard.png" alt="Airport Dashboard">
    <div class="caption">Figure 3: The Live Airport Dashboard showing real-time departures with City context.</div>

    <hr>

    <h2>üöÄ The Deployment Journey</h2>
    <p>I use <strong>Google Cloud Run</strong> for everything I build, and this was no exception. It is the closest
        thing we have to "magic" in DevOps.</p>
    <p><strong>The Workflow</strong>:</p>
    <ol>
        <li><strong>Dockerize</strong>: I created a multi-stage <code>Dockerfile</code> to produce a tiny (100MB)
            standalone image.</li>
        <li><strong>Deploy</strong>:
            <pre><code>gcloud run deploy flight-tracker --source . --allow-unauthenticated</code></pre>
        </li>
    </ol>
    <p><strong>The Result</strong>:</p>
    <ul>
        <li><strong>Cold Start</strong>: ~2 seconds (Acceptable for an MVP, optimizable with min-instances).</li>
        <li><strong>Request Latency</strong>: ~300ms (Thanks to Next.js Edge caching).</li>
        <li><strong>Cost</strong>: <strong>$0.00</strong> (Running entirely within the Free Tier).</li>
    </ul>

    <hr>

    <h2>üåê Custom Domain Setup (GoDaddy + Cloud Run)</h2>
    <p>To make it feel like a real product, I couldn't stick with the default <code>run.app</code> URL. Here is how I
        wired up a custom domain:</p>
    <ol>
        <li><strong>Domain Purchase</strong>: I grabbed a catchy <code>.com</code> on <strong>GoDaddy</strong>.</li>
        <li><strong>Cloud Run Mapping</strong>:
            <ul>
                <li>In the Cloud Run Console, I went to <strong>Manage Custom Domains</strong>.</li>
                <li>I selected my service (<code>flight-tracker</code>) and the new domain.</li>
                <li>Google generated a set of <strong>A</strong> and <strong>AAAA</strong> records for me.</li>
            </ul>
        </li>
        <li><strong>DNS Configuration</strong>:
            <ul>
                <li>Back in GoDaddy's <strong>DNS Management</strong> dashboard, I deleted the default parking records.
                </li>
                <li>I added the 4 'A' records and 4 'AAAA' records provided by Google.</li>
            </ul>
        </li>
        <li><strong>SSL Magic</strong>: Within 15 minutes, Google automatically provisioned a managed SSL certificate.
            No <code>certbot</code>, no renewals, just instant HTTPS.</li>
    </ol>

    <hr>
    <h2>üèÅ Lessons Learned & Roadmap</h2>
    <p>Building "Mission Control" taught me that the difference between a prototype and a product is in the details:
        handling timezones correctly, having fallback images for missing data, and handling API errors gracefully.</p>
    <p><strong>What's Next?</strong></p>
    <ul>
        <li><strong>"My Hangar"</strong>: A feature to pin/save flights to a persistent watchlist (using LocalStorage).
        </li>
        <li><strong>SMS Alerts</strong>: Hooking up APIs to text me when my Plane Lands.</li>
    </ul>
    <p><strong>Source Code</strong></p>
    <p>I've open-sourced the entire project. Feel free to fork it, star it, or use it as a template for your own
        "Mission Control" idea.</p>
    <p>üìÇ <strong>GitHub Repo</strong>: <a
            href="https://github.com/yourusername/flight-tracker">https://github.com/yourusername/flight-tracker</a></p>

    <p><strong>Try it yourself</strong>: <a
            href="https://flight-tracker-16016022795.us-central1.run.app">https://flight-tracker-16016022795.us-central1.run.app</a>
    </p>
    <p><em>Built with Next.js, Tailwind, and aviation passion.</em></p>

    <hr>

    <h2>üöß Work in Progress</h2>
    <p>This project is still an active work in progress! While the core features are stable, you might encounter edge
        cases with specific airports or airline data.</p>
    <p><strong>Notice any bugs?</strong> Please drop a comment below. I'm actively improving the dashboard and squashing
        bugs as they appear!</p>
</body>

</html>